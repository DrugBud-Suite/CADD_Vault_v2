const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-Cp6bVkxx.js","assets/index-B7rZpWz0.css"])))=>i.map(i=>d[i]);
var j=Object.defineProperty;var G=(m,e,t)=>e in m?j(m,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):m[e]=t;var k=(m,e,t)=>G(m,typeof e!="symbol"?e+"":e,t);import{Z as g,v as H}from"./index-Cp6bVkxx.js";class K{constructor(e){k(this,"query");k(this,"countQuery");k(this,"table");this.table=e,this.query=g.from(e).select("*"),this.countQuery=g.from(e).select("*",{count:"exact",head:!0})}select(e){return this.query=g.from(this.table).select(e),this}filter(e,t,o){return this.query=this.query[t](e,o),this.countQuery=this.countQuery[t](e,o),this}filters(e){return e.forEach(({field:t,operator:o,value:a})=>{this.filter(t,o,a)}),this}search(e,t){return t&&(this.query=this.query.ilike(e,`%${t}%`),this.countQuery=this.countQuery.ilike(e,`%${t}%`)),this}paginate(e,t){const o=e*t,a=o+t-1;return this.query=this.query.range(o,a),this}orderBy(e,t="asc"){return this.query=this.query.order(e,{ascending:t==="asc"}),this}async execute(){try{const[{data:e,error:t},{count:o}]=await Promise.all([this.query,this.countQuery]);if(t)throw t;return{data:e,count:o||0,error:null}}catch(e){return console.error(`Query failed on table ${this.table}:`,e),{data:null,count:0,error:e}}}}const b=m=>new K(m);class A{static getCachedData(e){const t=this.metadataCache.get(e);return t&&Date.now()-t.timestamp<this.CACHE_TTL?t.data:null}static setCachedData(e,t){this.metadataCache.set(e,{data:t,timestamp:Date.now()})}static clearCache(e){e?this.metadataCache.delete(e):this.metadataCache.clear()}static async fetchPackages(e){const{searchTerm:t,selectedTags:o=[],minStars:a=null,hasGithub:i,hasWebserver:r,hasPublication:c,minCitations:l=null,minRating:f=null,folder1:p=null,category1:y=null,selectedLicenses:C=[],sortBy:q="package_name",sortDirection:F="asc",page:x=1,pageSize:T=50,includeUserRatings:S=!1,currentUserId:D=null}=e;try{let s=g.from("packages").select(`
                    *,
                    package_tags!left(
                        tag_id,
                        tags!inner(id, name)
                    ),
                    package_folder_categories!left(
                        folder_category_id,
                        folder_categories!inner(
                            id,
                            folder_id,
                            category_id,
                            folders!inner(id, name),
                            categories!inner(id, name)
                        )
                    )
                `,{count:"exact"});if(t&&(s=s.or(`package_name.ilike.%${t}%,description.ilike.%${t}%`)),o.length>0){const{data:d}=await g.from("tags").select("id, name").in("name",o);if(d&&d.length>0){const h=d.map(n=>n.id);for(const n of h){const{data:u}=await g.from("package_tags").select("package_id").eq("tag_id",n);if(u&&u.length>0){const _=u.map(w=>w.package_id);s=s.in("id",_)}else s=s.eq("id","00000000-0000-0000-0000-000000000000")}}}if(p||y){let d=g.from("folder_categories").select("id");if(p){const{data:n}=await g.from("folders").select("id").eq("name",p).single();n&&(d=d.eq("folder_id",n.id))}if(y){const{data:n}=await g.from("categories").select("id").eq("name",y).single();n&&(d=d.eq("category_id",n.id))}const{data:h}=await d;if(h&&h.length>0){const n=h.map(_=>_.id),{data:u}=await g.from("package_folder_categories").select("package_id").in("folder_category_id",n);if(u&&u.length>0){const _=u.map(w=>w.package_id);s=s.in("id",_)}else s=s.eq("id","00000000-0000-0000-0000-000000000000")}}a!==null&&(s=s.gte("github_stars",a)),i===!0&&(s=s.not("repo_link","is",null)),r===!0&&(s=s.not("webserver","is",null)),c===!0&&(s=s.not("publication","is",null)),l!==null&&(s=s.gte("citations",l)),f!==null&&(s=s.gte("average_rating",f)),C.length>0&&(s=s.in("license",C)),q&&(s=s.order(q,{ascending:F==="asc"}));const v=(x-1)*T,B=v+T-1;s=s.range(v,B);const{data:O,error:M,count:U}=await s;if(M)throw M;const E=(O||[]).map(d=>{var h,n,u,_,w,I,Q,$,P;return{...d,tags:((h=d.package_tags)==null?void 0:h.map(N=>{var R;return(R=N.tags)==null?void 0:R.name}).filter(Boolean))||[],folder1:((w=(_=(u=(n=d.package_folder_categories)==null?void 0:n[0])==null?void 0:u.folder_categories)==null?void 0:_.folders)==null?void 0:w.name)||"",category1:((P=($=(Q=(I=d.package_folder_categories)==null?void 0:I[0])==null?void 0:Q.folder_categories)==null?void 0:$.categories)==null?void 0:P.name)||""}});let L;if(S&&D){const d=E.map(n=>n.id),{data:h}=await g.from("ratings").select("package_id, rating, id").eq("user_id",D).in("package_id",d);h&&(L=new Map(h.map(n=>[n.package_id,{rating:n.rating,rating_id:n.id}])))}return{packages:E,totalCount:U||0,userRatings:L}}catch(s){throw console.error("Error fetching packages:",s),s}}static async fetchUniqueTags(){var a;const e="unique_tags",t=this.getCachedData(e);if(t)return console.log("  📌 Tags loaded from cache"),t;console.log("  📌 Fetching unique tags...");const o=performance.now();try{const i=await b("tags").select("name").orderBy("name").execute();if(i.error)throw i.error;const r=((a=i.data)==null?void 0:a.map(c=>c.name))||[];return this.setCachedData(e,r),console.log(`  📌 Tags query completed in ${((performance.now()-o)/1e3).toFixed(2)}s`),r}catch(i){throw console.error("  ❌ Failed to fetch tags:",i),i}}static async fetchFoldersAndCategories(){console.log("  📁 Fetching folders and categories...");const e=performance.now();try{const{data:t,error:o}=await g.from("folder_categories").select(`
                    folders!inner(name),
                    categories!inner(name)
                `).order("folders(name), categories(name)");if(o)throw o;const a={};t==null||t.forEach(r=>{var f,p;const c=(f=r.folders)==null?void 0:f.name,l=(p=r.categories)==null?void 0:p.name;c&&l&&(a[c]||(a[c]=[]),a[c].includes(l)||a[c].push(l))}),Object.keys(a).forEach(r=>{a[r].sort()});const i=Object.keys(a).sort();return console.log(`  📁 Folders/Categories fetched in ${((performance.now()-e)/1e3).toFixed(2)}s`),{folders:i,categories:a}}catch(t){throw console.error("  ❌ Failed to fetch folders/categories:",t),t}}static async fetchPackagesWithTag(e){try{const{data:t,error:o}=await g.from("tags").select("id").eq("name",e.trim()).single();if(o||!t)return[];const{data:a,error:i}=await g.from("packages").select(`
                    *,
                    package_tags!inner(tag_id),
                    package_tags!left(
                        tags!inner(id, name)
                    ),
                    package_folder_categories!left(
                        folder_categories!inner(
                            folders!inner(name),
                            categories!inner(name)
                        )
                    )
                `).eq("package_tags.tag_id",t.id);if(i)throw i;return(a||[]).map(r=>{var c,l,f,p,y,C,q,F,x;return{...r,tags:((c=r.package_tags)==null?void 0:c.map(T=>{var S;return(S=T.tags)==null?void 0:S.name}).filter(Boolean))||[],folder1:((y=(p=(f=(l=r.package_folder_categories)==null?void 0:l[0])==null?void 0:f.folder_categories)==null?void 0:p.folders)==null?void 0:y.name)||"",category1:((x=(F=(q=(C=r.package_folder_categories)==null?void 0:C[0])==null?void 0:q.folder_categories)==null?void 0:F.categories)==null?void 0:x.name)||""}})}catch(t){throw console.error("Error fetching packages with tag:",t),t}}static async fetchFilterMetadata(){console.log("📊 Fetching filter metadata...");const e=performance.now();try{console.log("📊 Starting parallel metadata queries...");const[t,o,a,i]=await Promise.all([this.fetchUniqueTags(),this.fetchUniqueLicenses(),this.fetchFoldersAndCategories(),this.fetchDatasetStats()]),r=((performance.now()-e)/1e3).toFixed(2);return console.log(`📊 Metadata fetch completed in ${r}s`),{allAvailableTags:t,allAvailableLicenses:o,allAvailableFolders:a.folders,allAvailableCategories:a.categories,datasetMaxStars:i.maxStars||0,datasetMaxCitations:i.maxCitations||0,totalPackageCount:i.totalCount}}catch(t){throw console.error("❌ Error fetching filter metadata:",t),t}}static async fetchUniqueLicenses(){var a,i;const e="unique_licenses",t=this.getCachedData(e);if(t)return console.log("  📜 Licenses loaded from cache"),t;console.log("  📜 Fetching unique licenses...");const o=performance.now();try{const r=await b("packages").select("license").filter("license","not","is.null").execute();if(r.error)throw console.error("  ❌ Licenses query error:",r.error),r.error;const c=new Set;(a=r.data)==null||a.forEach(f=>{f.license&&f.license.trim()&&c.add(f.license.trim())});const l=Array.from(c).sort();return this.setCachedData(e,l),console.log(`  📜 Licenses query completed, processed ${((i=r.data)==null?void 0:i.length)||0} rows in ${((performance.now()-o)/1e3).toFixed(2)}s`),l}catch(r){throw console.error("  ❌ Failed to fetch licenses:",r),r}}static async fetchDatasetStats(){var t,o,a,i;console.log("  📊 Fetching dataset statistics...");const e=performance.now();try{console.log("    ⭐📚🔢 Fetching all stats in parallel...");const[r,c,l]=await Promise.all([b("packages").select("github_stars").filter("github_stars","not","is.null").orderBy("github_stars","desc").paginate(0,1).execute(),b("packages").select("citations").filter("citations","not","is.null").orderBy("citations","desc").paginate(0,1).execute(),b("packages").select("id").execute()]);if(r.error)throw console.error("    ❌ Max stars query error:",r.error),r.error;if(c.error)throw console.error("    ❌ Max citations query error:",c.error),c.error;if(l.error)throw console.error("    ❌ Count query error:",l.error),l.error;return console.log(`  📊 Stats queries completed in ${((performance.now()-e)/1e3).toFixed(2)}s`),{maxStars:((o=(t=r.data)==null?void 0:t[0])==null?void 0:o.github_stars)||null,maxCitations:((i=(a=c.data)==null?void 0:a[0])==null?void 0:i.citations)||null,totalCount:l.count||0}}catch(r){throw console.error("  ❌ Failed to fetch dataset stats:",r),r}}static applyTagFilters(e,t,o="OR"){if(t.length===0)return e;switch(o){case"OR":return e.filter("tags","cs",JSON.stringify(t));case"AND":return t.forEach(a=>{e=e.contains("tags",[a])}),e;case"SINGLE":return e.contains("tags",[t[0]]);default:return e}}static async refreshFilterMetadata(){console.log("🔄 Refreshing filter metadata...");try{const e=await this.fetchFilterMetadata(),{useFilterStore:t}=await H(async()=>{const{useFilterStore:o}=await import("./index-Cp6bVkxx.js").then(a=>a.aI);return{useFilterStore:o}},__vite__mapDeps([0,1]));t.setState({allAvailableTags:e.allAvailableTags,allAvailableLicenses:e.allAvailableLicenses,allAvailableFolders:e.allAvailableFolders,allAvailableCategories:e.allAvailableCategories,datasetMaxStars:e.datasetMaxStars,datasetMaxCitations:e.datasetMaxCitations}),console.log("✅ Filter metadata refreshed successfully")}catch(e){throw console.error("❌ Error refreshing filter metadata:",e),e}}}k(A,"metadataCache",new Map),k(A,"CACHE_TTL",5*60*1e3);const J=Object.freeze(Object.defineProperty({__proto__:null,DataService:A},Symbol.toStringTag,{value:"Module"}));export{A as D,b as c,J as d};
