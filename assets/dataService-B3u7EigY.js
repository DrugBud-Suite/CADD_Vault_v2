const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-2WJagF89.js","assets/index-B7rZpWz0.css"])))=>i.map(i=>d[i]);
import{v as P,a2 as h}from"./index-2WJagF89.js";class U{static async fetchFilterMetadata(){console.log("📊 Fetching filter metadata...");const n=performance.now();try{console.log("📊 Starting parallel metadata queries...");const e=this.fetchUniqueTags().then(r=>(console.log(`✅ Tags fetched: ${r.length} unique tags`),r)).catch(r=>{throw console.error("❌ Error fetching tags:",r),r}),a=this.fetchUniqueLicenses().then(r=>(console.log(`✅ Licenses fetched: ${r.length} unique licenses`),r)).catch(r=>{throw console.error("❌ Error fetching licenses:",r),r}),t=this.fetchFoldersAndCategories().then(r=>(console.log(`✅ Folders/Categories fetched: ${r.folders.length} folders`),r)).catch(r=>{throw console.error("❌ Error fetching folders/categories:",r),r}),i=this.fetchDatasetStats().then(r=>(console.log(`✅ Stats fetched: ${r.totalCount} total packages`),r)).catch(r=>{throw console.error("❌ Error fetching stats:",r),r}),[l,c,g,s]=await Promise.all([e,a,t,i]),f=((performance.now()-n)/1e3).toFixed(2);return console.log(`📊 Metadata fetch completed in ${f}s`),{allAvailableTags:l,allAvailableLicenses:c,allAvailableFolders:g.folders,allAvailableCategories:g.categories,datasetMaxStars:s.maxStars,datasetMaxCitations:s.maxCitations,totalPackageCount:s.totalCount}}catch(e){throw console.error("❌ Error fetching filter metadata:",e),e}}static async refreshFilterMetadata(){console.log("🔄 Refreshing filter metadata...");try{const n=await this.fetchFilterMetadata(),{useFilterStore:e}=await P(async()=>{const{useFilterStore:a}=await import("./index-2WJagF89.js").then(t=>t.aH);return{useFilterStore:a}},__vite__mapDeps([0,1]));e.setState({allAvailableTags:n.allAvailableTags,allAvailableLicenses:n.allAvailableLicenses,allAvailableFolders:n.allAvailableFolders,allAvailableCategories:n.allAvailableCategories,datasetMaxStars:n.datasetMaxStars,datasetMaxCitations:n.datasetMaxCitations}),console.log("✅ Filter metadata refreshed successfully")}catch(n){throw console.error("❌ Error refreshing filter metadata:",n),n}}static async fetchPackages(n){const{searchTerm:e,selectedTags:a=[],minStars:t=null,hasGithub:i,hasWebserver:l,hasPublication:c,minCitations:g=null,minRating:s=null,folder1:f,category1:r,selectedLicenses:m=[],sortBy:p="package_name",sortDirection:T="asc",page:w=1,pageSize:y=24,includeUserRatings:C=!1,currentUserId:F=null}=n,v=performance.now(),k=(w-1)*y,A=k+y-1;console.log(`🔎 Fetching packages (page ${w})...`);try{let o=h.from("packages").select("*",{count:"exact"});e&&(o=o.or(`package_name.ilike.%${e}%,description.ilike.%${e}%`)),a.length>0&&(o=o.overlaps("tags",a)),t!==null&&t>0&&(o=o.gte("github_stars",t)),i&&(o=o.not("repo_link","is",null)),l&&(o=o.not("webserver","is",null)),c&&(o=o.not("publication","is",null)),g!==null&&g>0&&(o=o.gte("citations",g)),s!==null&&s>0&&(o=o.gte("average_rating",s)),f&&(o=o.eq("folder1",f)),r&&(o=o.eq("category1",r)),m.length>0&&(o=o.in("license",m)),p&&(o=o.order(p,{ascending:T==="asc",nullsFirst:!1})),o=o.range(k,A);const{data:E,error:b,count:_}=await o;if(b)throw b;let d=E||[];if(C&&F&&d.length>0){console.log(`🔖 Fetching user ratings for ${d.length} packages...`);const $=d.map(u=>u.id),q=await this.fetchUserRatingsForPackages($,F);d=d.map(u=>{var S,x;return{...u,user_rating:((S=q.get(u.id))==null?void 0:S.rating)||null,user_rating_id:((x=q.get(u.id))==null?void 0:x.rating_id)||null}})}const M=((performance.now()-v)/1e3).toFixed(2);return console.log(`🔎 Package fetch completed in ${M}s. Total matches: ${_}, returned: ${d.length}`),{packages:d,totalCount:_||0}}catch(o){throw console.error("❌ Error fetching packages:",o),o}}static async fetchUserRatingsForPackages(n,e){try{const{data:a,error:t}=await h.from("ratings").select("package_id, rating, id").eq("user_id",e).in("package_id",n);if(t)throw t;const i=new Map;return a&&a.forEach(l=>{i.set(l.package_id,{rating:l.rating,rating_id:l.id})}),i}catch(a){return console.error("Error fetching user ratings for packages:",a),new Map}}static async fetchUserRatingForPackage(n,e){try{const{data:a,error:t}=await h.from("ratings").select("rating, id").eq("user_id",e).eq("package_id",n).single();if(t){if(t.code==="PGRST116")return null;throw t}return{rating:a.rating,rating_id:a.id}}catch(a){return console.error("Error fetching user rating for package:",a),null}}static async fetchUniqueTags(){console.log("  📌 Fetching unique tags...");const n=performance.now();try{const e=new Set;let a=0;const t=1e3;let i=!0,l=0;for(;i;){const{data:c,error:g}=await h.from("packages").select("tags").not("tags","is",null).range(a,a+t-1);if(g)throw console.error("  ❌ Tags query error:",g),g;if(!c||c.length===0){i=!1;break}c.forEach(s=>{s.tags&&Array.isArray(s.tags)&&s.tags.forEach(f=>{f&&f.trim()&&e.add(f.trim())})}),l+=c.length,i=c.length===t,a+=t}return console.log(`  📌 Tags query completed, processed ${l} total rows in ${((performance.now()-n)/1e3).toFixed(2)}s`),Array.from(e).sort()}catch(e){throw console.error("  ❌ Failed to fetch tags:",e),e}}static async fetchUniqueLicenses(){console.log("  📜 Fetching unique licenses...");const n=performance.now();try{const e=new Set;let a=0;const t=1e3;let i=!0,l=0;for(;i;){const{data:c,error:g}=await h.from("packages").select("license").not("license","is",null).range(a,a+t-1);if(g)throw console.error("  ❌ Licenses query error:",g),g;if(!c||c.length===0){i=!1;break}c.forEach(s=>{s.license&&s.license.trim()&&e.add(s.license.trim())}),l+=c.length,i=c.length===t,a+=t}return console.log(`  📜 Licenses query completed, processed ${l} total rows in ${((performance.now()-n)/1e3).toFixed(2)}s`),Array.from(e).sort()}catch(e){throw console.error("  ❌ Failed to fetch licenses:",e),e}}static async fetchFoldersAndCategories(){console.log("  📁 Fetching folders and categories...");const n=performance.now();try{const e={};let a=0;const t=1e3;let i=!0,l=0;for(;i;){const{data:s,error:f}=await h.from("packages").select("folder1, category1").not("folder1","is",null).range(a,a+t-1);if(f)throw console.error("  ❌ Folders/categories query error:",f),f;if(!s||s.length===0){i=!1;break}s.forEach(r=>{r.folder1&&(e[r.folder1]||(e[r.folder1]=new Set),r.category1&&e[r.folder1].add(r.category1))}),l+=s.length,i=s.length===t,a+=t}console.log(`  📁 Folders/categories query completed, processed ${l} total rows in ${((performance.now()-n)/1e3).toFixed(2)}s`);const c=Object.keys(e).sort(),g={};for(const s in e)g[s]=Array.from(e[s]).sort();return{folders:c,categories:g}}catch(e){throw console.error("  ❌ Failed to fetch folders/categories:",e),e}}static async fetchDatasetStats(){var e,a;console.log("  📊 Fetching dataset statistics...");const n=performance.now();try{console.log("    ⭐ Fetching max stars...");const{data:t,error:i}=await h.from("packages").select("github_stars").not("github_stars","is",null).order("github_stars",{ascending:!1}).limit(1);if(i)throw console.error("    ❌ Max stars query error:",i),i;console.log("    📚 Fetching max citations...");const{data:l,error:c}=await h.from("packages").select("citations").not("citations","is",null).order("citations",{ascending:!1}).limit(1);if(c)throw console.error("    ❌ Max citations query error:",c),c;console.log("    🔢 Fetching total count...");const{count:g,error:s}=await h.from("packages").select("*",{count:"exact",head:!0});if(s)throw console.error("    ❌ Count query error:",s),s;return console.log(`  📊 Stats queries completed in ${((performance.now()-n)/1e3).toFixed(2)}s`),{maxStars:((e=t==null?void 0:t[0])==null?void 0:e.github_stars)||null,maxCitations:((a=l==null?void 0:l[0])==null?void 0:a.citations)||null,totalCount:g||0}}catch(t){throw console.error("  ❌ Failed to fetch dataset stats:",t),t}}}export{U as DataService};
